<!DOCTYPE html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>–ó–∞–∫—Ä—ã—Ç—å —Å—Ä–∞–∑—É</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
		integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
		integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous">
	</script>
	<script src="https://telegram.org/js/telegram-web-app.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/browser-image-compression@1.0.12/dist/browser-image-compression.js"></script>
	<style>
		body {
			margin: 25px 25px;
			font-size: 1.5rem;
		}

		h1, h3 {
			text-align: center;
		}

		.btn {
			width: 100%;
		}

		.wrapper {
			display: flex;
			justify-content: center;
			align-items: center;
		}

		.stripes {
			width: 100%;
			height: 10px;
			background-color: white;
			border-radius: 5px;
			box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15), 0 8px 16px rgba(0, 0, 0, 0.2);
		}

		.stripe--blue {
			background-color: blue;
		}

		.stripe--red {
			background-color: red;
		}

		#loader {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			z-index: 1000;
			display: flex;
			justify-content: center;
			align-items: center;
			background-color: rgba(255, 255, 255, 0.8);
			opacity: 0;
			visibility: hidden;
			transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
		}

		#loader.show {
			opacity: 1;
			visibility: visible;
			transition-delay: 0s;
		}
	</style>
</head>

<body>
	<div class="shadow p-3 bg-body rounded">
		<h1>–û—Å—Ç–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ</h1>
		<h3>‚Ññ</h3>
	</div>
	<div class="wrapper mb-5">
		<div class="stripes stripe--white"></div>
		<div class="stripes stripe--blue"></div>
		<div class="stripes stripe--red"></div>
	</div>
	<label for="message" class="mb-3">üìÉ –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ</label>
	<div class="form-floating">
		<textarea id="message" class="form-control mb-3" style="max-height: 550px; min-height: 250px; padding-top: 15px; font-size: 20px; resize: vertical;"></textarea>
	</div>
	<div class="form-check form-switch-lg mb-3">
		<input class="form-check-input" type="checkbox" id="tosender">
		<label class="form-check-label" for="tosender">‚úâÔ∏è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—é</label>
	</div>
	<div>
		<label for="formFileLg" class="form-label">üñºÔ∏è –í–ª–æ–∂–∏—Ç—å —Ñ–æ—Ç–æ</label>
		<input class="form-control form-control-lg mb-5" id="formFileLg" type="file" accept="image/*" multiple>
	</div>
	<button type="submit" class="btn btn-outline-danger btn-lg" onclick="submit();">–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å</button>
	<div id="loader" class="loader">
		<img src="loading.gif" alt="GIF image">
		<br>
		<p>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...</p>
	</div>
	<script>
		const urlParams = new URLSearchParams(window.location.search);
			const ticketID = urlParams.get('ticketID');
			const h3 = document.querySelector('h3');
				h3.innerText += " "+ticketID;
		const forms = ['message'];
		const apiUrl = 'https://script.google.com/macros/s/AKfycbwRXVLd8j-F-X9PC6EXNaHMAKcElipLBgPz1poNd5LDmk65z4W3oGSKa-o1f2Io4MTIcw/exec';
		const tgApp = window.Telegram.WebApp;
			tgApp.expand();
			tgApp.disableVerticalSwipes();
			tgApp.setHeaderColor('#FFC300');
		const tgUser = tgApp.initDataUnsafe.user;
		const loader = document.getElementById('loader');
			const loaderText = '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...';
		
		function submit() {
			let r = checkForms(forms);
			if (r.ok) {
					loading(true);
						sendImages();
					loading(false);
			} else {
				tgAlert(r.error);
			}
		};

		function checkRights(url, callback) {
		 fetch(url)
		  .then(response => {
			  if (!response.ok) {
				  throw new Error(`HTTP error! Status: ${response.error}`);
			  }
			  return response.json();
		  })
		  .then(data => {
			  if (data.ismoderator) {
				  result = true;
			  } else {
				  result = false;
			  }
			  callback(result);
		  })
		  .catch(error => {
			tgAlert(error);
			callback(false);
		  });
		}
		
		function sendOrder(url, callback) {
		 fetch(url)
		  .then(response => {
			  if (!response.ok) {
				  throw new Error(`HTTP error! Status: ${response.error}`);
			  }
			  return response.json();
		  })
		  .then(data => {
			  callback(data);
		  })
		  .catch(error => {
			tgAlert(error);
			callback(false);
		  });
		}

		async function uploadFiles(e, callback) {
			const files = Array.from(e);

            for (let i = 0; i < Math.min(files.length, 3); i++) {
                const file = files[i];
                const formData = new FormData();
                formData.append('chat_id', chatId);
                formData.append('photo', file);

                try {
                    await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
                        method: 'POST',
                        body: formData,
                    });
                    tgAlert(`–§–æ—Ç–æ ${i + 1} —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.`);
                } catch (error) {
                    tgAlert(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–æ—Ç–æ ${i + 1}: `+error);
                }
            }
		}

		// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∂–∞—Ç–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
		async function compressImage(file) {
		  const options = {
			maxSizeMB: 1,
			maxWidthOrHeight: 1920,
			useWebWorker: true
		  };
		  
		  try {
			const compressedFile = await imageCompression(file, options);
			return compressedFile;
		  } catch (error) {
			tgAlert('–û—à–∏–±–∫–∞ —Å–∂–∞—Ç–∏—è —Ñ–∞–π–ª–∞: '+error);
			throw error;
		  }
		}

		async function sendImages() {
			const imageInput = document.getElementById('formFileLg');
			const file = imageInput.files[0];

			if (!file) {
				tgAlert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
				return;
			}

			const compressedImage = await resizeImage(file, 0.7); // –°—Ç–µ–ø–µ–Ω—å —Å–∂–∞—Ç–∏—è 70%
			const formData = new FormData();
			formData.append('image', compressedImage);

			try {
				const response = await fetch(apiUrl, {
					method: 'POST',
					body: formData
				});

				const result = await response.json();
				console.log('–û—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞:', result);
				tgAlert('–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ!');
			} catch (error) {
				console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
				tgAlert(`–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: ${error.message}`);
			}
		}

		function resizeImage(image, quality) {
			return new Promise((resolve, reject) => {
				if (!image.type.match(/image.*/)) {
					reject(new Error('–§–∞–π–ª –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º.'));
					return;
				}

				const reader = new FileReader();
				reader.onload = (readerEvent) => {
					const img = new Image();
					img.onload = () => {
						const canvas = document.createElement('canvas');
						const maxSize = 1200; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
						let width = img.width;
						let height = img.height;

						if (width > height) {
							if (width > maxSize) {
								height *= maxSize / width;
								width = maxSize;
							}
						} else {
							if (height > maxSize) {
								width *= maxSize / height;
								height = maxSize;
							}
						}

						canvas.width = width;
						canvas.height = height;
						const ctx = canvas.getContext('2d');
						ctx.drawImage(img, 0, 0, width, height);

						const resizedImage = canvas.toBlob(
							blob => resolve(new File([blob], image.name, { type: 'image/jpeg' })),
							'image/jpeg',
							quality
						);
					};

					img.src = readerEvent.target.result;
				};

				reader.readAsDataURL(image);
			});
		}

		async function sendMediaGroup(media) {
			try {
				const response = await fetch(apiUrl, {
					method: 'POST',
					headers: {
						'Content-Type': 'multipart/form-data'
					},
					body: JSON.stringify({
						chat_id: 'test',
						media: media
					})
				});

				const result = await response.json();
				if (result.ok) {
					tgAlert('–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã!');
				} else {
					throw new Error(result.description);
				}
			} catch (error) {
				console.error(error);
				tgAlert(`–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: ${error.message}`);
			}
		}

		function checkForms(arr) {
			for (const f in arr) {
				let form = document.getElementById(arr[f]);
				if (form.value.trim() == '' || form.value.trim() == 0) {
					return {
						ok: false,
						error: "–í—ã –Ω–µ –∑–∞–ø–æ–ª–Ω–∏–ª–∏ —Ç—Ä–µ–±—É–µ–º—ã–µ –ø–æ–ª—è..."
					};
				}
			}
			return {
				ok: true
			};
		};
		
		function loading(show) {
			if (show instanceof Boolean) {
				if (!show) {
					loader.classList.remove('show');
				} else {
					loader.classList.add('show');
				}
			} else {
				const p = document.querySelector('p');
				p.innerText = loaderText+"<br>"+show;
			}
		};
		
		function tgAlert(text) {
			tgApp.HapticFeedback.impactOccurred('medium');
			tgApp.showAlert('–°–æ–æ–±—â–µ–Ω–∏–µ:\n'+text);
		};

		document.addEventListener('DOMContentLoaded', function() {
				//checkRights(apiUrl+'?doit=check&uid='+tgUser.id, result => {
				//	if (result) {
				//		loading(false);
				//	} else {
				//		window.location.replace("https://timusov.github.io/list/denied.html");
				//	}
				//});
		});
		
		document.getElementById('formFileLg').addEventListener('change', function(e) {
			let files = e.target.files;

			if (files.length > 5) {
				tgAlert('–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–µ –±–æ–ª–µ–µ 5 —Ñ–∞–π–ª–æ–≤.');
				e.target.value = '';
				return;
			}
			
			for (let i = 0; i < files.length; i++) { 
				if (files[i].size> 9 * 1024 * 1024) {
					tgAlert('–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç 20 –ú–ë.');
					e.target.value = '';
					break;
				}
			}
		});
</script>
</body>
</html>